## 一、关系型数据库

采用关系模式来组成数据库，其数据以行和列的形式存在，便于用户理解。行和列的形式称为表，一组表就组成了一个数据库。

按照数据结构来组织、存储和管理数据，实际上总共有三种模型：

*   层次模型
*   网状模型
*   关系模型

关系模型就是

---

关于数据库的一些特征：

*   数据库：数据库是一些关联表的集合。
*   数据表：表示数据的矩阵，在一个数据库中有很多的表。
*   列：一列元素包含相同的数据类型。
*   行：（=元组）是一组相关的数据，比如一个用户的一些姓名，性别，年龄等等。
*   冗余：存储两倍数据，冗余降低了性能，但是提高了数据的安全性。
*   主键：主键是唯一的，一个数据表中只有一个主键。
*   外键：外键用于关联两个表。
*   复合键：将多个列作为一个索引键，一般用于符合索引。
*   索引：使用索引可以快速访问数据库中的特定信息，索引是对数据库表中一列或者多了的值进行排序的一种结构，类似于书记的目录。
*   参照完整性：参照的完整性要求关系中不允许引用不存在的实体。参照完整性和实体完整性是关系模型必须满足的完整性约束条件。目的是保证数据的一致性。

SQL事物：

参考：https://www.runoob.com/mysql/mysql-transaction.html

一般来讲，事物必须满足4个条件（ACID）：原子性（Atomicity，或称不可分割性）、一致性（Consistency）、隔离性（Isolation，又称独立性）、持久性（Durability）。

*   原子性：一个事物中的操作要么全部完成，要么全部不完成。不会结束在中间的某个环节，事物在执行过程中发生错误的话会被回滚到事物开始前的状态。
*   一致性：在事物开始前和事物结束后数据库的完整性没有被破坏、这表示着写入的资料必须完全符合所有的预设规则，这包含资料的精确度，串联性以及后续数据库可以自发性的完成预定的的工作。
*   隔离性：数据库允许多个并发事物同时对数据进行读写和修改的能力，隔离性可以防止多个事物并发执行是由于交叉执行而导致数据的不一致，事物的隔离分为不同级别，包括读未提交、读提交、可重复读、和串行化。
*   持久性：事物处理结束后，对数据的修改就是永久的，即使系统故障也不会丢失。

待补充......

### **SQL语句：**  ###

```mysql
case 
	when condition then
	when condition then
```



##### 连接表： #####

```sql
SELECT
	field1,
	field2,
	...,
	field 
FROM
	tablename1
	LEFT JOIN tablename2 ON tablename1.id = tablename2.id
```

**关于连接方式：** 参考：https://www.zsythink.net/archives/1105

分为：`cross join， inner join，left join，right join，union，union all，full join。 ` 

#####  排序： #####

```sql
SELECT
	field1,
	field2,
	...,
	field 
FROM
	tablename 
ORDER BY
	field1
```

按照 `field1` 进行排序。

```sql
SELECT
	max( Salary ) AS SecondHighestSalary 
FROM
	Employee 
WHERE
	Salary < (
	SELECT
		max( Salary ) 
FROM
	Employee)
```

```sql
SELECT
	IFNULL( ( SELECT DISTINCT Salary FROM Employee ORDER BY Salary DESC LIMIT 1 OFFSET 1 ), NULL ) AS SecondHighestSalary
```

查询表格中第二大的数据。



**MySQL中编写函数：**

```sql
create function 函数名([参数列表]) returns 数据类型
begin
 sql语句;
 return 值;
end;
```

```sql
CREATE FUNCTION getNthHighestSalary(N INT) RETURNS INT
BEGIN
    SET N = N - 1;
  RETURN (
      # Write your MySQL query statement below.
      SELECT
	    IFNULL( ( SELECT DISTINCT Salary FROM Employee ORDER BY Salary DESC LIMIT N, 1 ), NULL ) AS SecondHighestSalary
  );
END
```

**注意 `limit` 和 `limit offset` 使用的区别。**

`limit` ：含义是跳过2条取出1条数据，limit后面是从第2条开始读，读取1条信息，即读取第3条数据。

`limit offset` ：含义是从第1条（不包括）数据开始取出2条数据，limit后面跟的是2条数据，offset后面是从第1条开始读取，即读取第2,3条。



### 使用Python操作MySQL。

查询数据：

```python
def creatr_thing():
    try:
        db = pymysql.connect(host='localhost', user='root', password='password', database='world')
        db.autocommit(True)
        db_curs = db.cursor()
        print('连接成功...')
        sql_ = "select * from city\
                where CountryCode='NLD'"
        db_curs.execute(sql_)
        result = db_curs.fetchall()
        print(type(result))
        for i in result:
            print(type(i))
            print(i)
    except Exception as err:
        print(err)
```

查询到的结果为一个元组，元组套元组的格式。

插入数据：

```python
class DyttPipeline(object):
    def process_item(self, item, spider):
        # print(item["movie"])
        # print("*" * 100)
        # print(item)
        insert_data = [item["movie_date"], item["movie_name"], item["movie_url"]]
        print(insert_data)
        
        db = pymysql.connect(host="localhost", user="root", password="password", database="world")
        db_curs = db.cursor()
        insert_sql = """INSERT INTO dytt_1(movie_date, movie_name, movie_url) VALUES (%s, %s, %s);"""
        data = [insert_data]
        # print(data)
        try:
            db_curs.executemany(insert_sql, data)
            db.commit()
            print("ok")
        except:
            db.rollback()
            print("insert error")
        db_curs.close()
        print("This is a message")
        return item
```

----

查找 MySQL 中重复的数据：

```mysql
SELECT id, movie_url, COUNT(*) FROM dytt_1 GROUP BY movie_name HAVING COUNT(*) > 1
```

返回的结果是重复次数大于 1 的项目数。

删除 MySQL 中重复的数据：

```mysql
DELETE 
FROM
	dytt_1 
WHERE
	movie_name IN (
SELECT
	t.movie_name 
FROM
	( SELECT movie_name FROM dytt_1 GROUP BY movie_name HAVING COUNT( * ) > 1 ) t ) 
AND id NOT IN (
SELECT
	dt.m
FROM
	( SELECT MIN( id ) AS m FROM dytt_1 GROUP BY movie_name HAVING COUNT( * ) > 1 ) dt 
	)
```

这样删除之后就会成为不重复的数据，但是 id 就会变得很跳跃，就已经不是连续的了。如果需要将 id 变为连续的，那么有一个办法就是将目前的数据写入到一个新的表中，将 id 设为自增，前提是要设置 id 为 `int` 类型。

**更改数据表的名称：** 

```sql
ALTER TABLE tablename1 RENAME TO tablename2;
```

**往 MySQL 中插入少量数据：** 

```sql
INSERT INTO databasename (field1, field2, ..., field) VALUES (field1, field2, ..., field)
```

**更新 SQL 中的少量数据：**

```sql
UPDATE databasename SET field1 = 'data1', field2 = 'data2', ..., field = 'data' WHERE id = n
```

**将一个表中的数据全部放到另外一个表中：** 

```sql
INSERT INTO tablename1 ( field1, field2, ..., field ) SELECT
field1,
field2,
.,
.,
.,
field 
FROM
	tablename2
```

tablename1 是要保存新数据的表，tablename2 是原表，需要这种操作一般是在原表删除数据之后，id 不连续增长，将其放在新表里面让 id 连续。在 tablename1 中的列名要和 tablename2 中的列名一一对应。**如果是需要从数据库A中的表添加数据到数据库B中的表，则需要在查询语句是添加数据库名，如`databasename.tablename`**。

*关于MySQL的存储过程： MySQL储存过程是一组为了完成特定功能的SQL语句集，经过编译之后存储在数据库中，当需要使用该组SQL语句时用户只需要通过指定储存过程的名字并给定参数就可以调用执行它了，简而言之就是一组已经写好的命令，需要使用的时候拿出来用就可以了。* 

MySQL存储过程是一个可编写的函数，在数据库中创建并保存，它可以有一些SQL语句和一些特殊的控制结构组成。

...



## 二、非关系型数据库  ##

关于 `Redis` 和 `MongoDB` 的区别：https://www.cnblogs.com/java-spring/p/9488227.html

### 1、`Redis`   ###

`Redis`是一个开源的使用ANSI C语言编写、遵守BSD协议、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。 

它通常被称为数据结构服务器，因为值（value）可以是 字符串(String), 哈希(Hash), 列表(list), 集合(sets) 和 有序集合(sorted sets)等类型。

`Redis` 与其他 key - value 缓存产品有以下三个特点：

-   `Redis`支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。
-   `Redis`不仅仅支持简单的key-value类型的数据，同时还提供`list，set，zset，hash`等数据结构的存储。
-   `Redis`支持数据的备份，即master-slave模式的数据备份。

安装之后，在 `cmd` 命令行使用下面的命令运行 `redis` 服务。

```
redis-server.exe
```

默认的端口号为 6379。

关于 `Redis` 的管理工具，我使用的一个是 `Redis Desktop Manage` 另外一个是网页版的 `treesoft` 。个人觉得可以两个结合起来用，会比较方便。

关于`redis shell`： 

在启动`redis` 服务之后，打开新的命令提示符窗口，输入`redis-cli --raw` 就可以进入到 shell 命令行了。输入`keys *` 可以得到所有的键的名称。`dbsize`可以得到键的个数。*但是目前存在一个问题，就是在`redis shell` 中输入中文会显示乱码的问题，并不是编码错误。* 



**`redis`持久化**：由于`redis`是内存型数据，当内存断电之后会丢失数据，所以为了保证数据不丢失需要进行持久化。

RDB持久化：会将某个时间点的所有数据存放到硬盘上；可以将快照复制到其他服务器从而创建相同数据库的服务器副本；如果发生故障，将会丢失最后一次创建快照之后的数据；如果数据量比较大，保存快照的时间会比较长。

AOF持久化：使用AOF持久化需要设置同步选项，从而确保写命令同步到磁盘上的时机。这是因为对文件进行写入操作并不会立即将内容同步到磁盘上，而是先到缓存区，然后由操作系统决定什么时候写入到磁盘中。有三个命令：

always：每个命令都同步（这个会严重降低服务器的性能，）；`everysec`：每秒都同步（如果系统发生崩溃，只是丢失一秒的数据，并且`Redis`每秒执行一次对服务器的影响也比较小）；no：让操作系统决定何时同步（对于服务器性能没有影响，然而系统崩溃是会丢失比较多的数据）。

***AOF在默认的`redis.windows.conf`中是关闭的，具体在配置文件中显示的是：`appendonly no`，所以需要改变参数，将 no 改为 yes ，然后在目录下面会生成一个`appendonl.aof`文件。而且，RDB持久化和AOF持久化是不冲突的。*** 

 随着服务器写请求的增多，AOF 文件会越来越大。`Redis` 提供了一种将 AOF 重写的特性，能够去除 AOF 文件中的冗余写命令。参考： https://blog.csdn.net/hezhiqiang1314/article/details/69396887#aof-重写 

两者的比较 ：

1、AOF比RDB的频率高，优先使用AOF还原数据。

2、AOF比RDB的安全性也更大。

3、RDB的性能比AOF好。

4、如果两个都配置了，优先加载AOF。

`Redis`通讯协议RESP：是`Redis`中客户端和服务端的一种通讯方式。**特点：** 实现简单，快速解析，可读性好。



#### 使用 Python 操作 `Redis`   ####

```python
def operating_redis():
    """
    操作 Redis
    """
    try:
        pool = redis.ConnectionPool(host='localhost', port=6379, decode_responses=True)
        r = redis.Redis(connection_pool=pool)
        # 建立 redis 的连接池，对每次连接是不影响，设置decode_responses=True可以保证返回结果正常显示
        # print("连接成功...")
        movie_date = r.lrange('movie_date', 0, -1)
        movie_name = r.lrange('movie_name', 0, -1)
        movie_url = r.lrange('movie_url', 0, -1)

        movie_date_new = list(set(movie_date))
        movie_name_new = list(set(movie_name))
        movie_url_new = list(set(movie_url))

        write_in_redis('movie_date_new', movie_date_new)
        write_in_redis('movie_name_new', movie_name_new)
        write_in_redis('movie_url_new', movie_url_new)
    except Exception as err :
        print(err)
        

def write_in_redis(key_name: str, value: list):
    """
    上面函数的附加函数，写入数据库时调用。
    """
    pool = redis.ConnectionPool(host='localhost', port=6379, decode_responses=True)
    r = redis.Redis(connection_pool=pool)
    for l in value:
        r.sadd(key_name, l)
```

上面两个函数的作用是去除数据库中的重复数据。首先第一个函数建立连接池连接 `redis` 数据库，然后读取数据库中的数据，使用 `set()` 判断是否有重复数据，对比长度即可。然后将新的集合保存到新的变量，通过下面的函数逐一遍历写到 `redis` 中。

对于处理重复数据来讲，少量数据可能 `redis` 比较方便。在 MySQL 中删除重复数据之后 ID 就会变得不连续，所以需要将数据重新导入新表中。

---

#### `Redis` ####

##### 1、`Redis`中可以保存的数据类型？ #####

##### 2、持久化方式以及优缺点？ #####

##### 3、`Redis` 中的架构方式有哪些及其特点？ #####

##### 4、常用命令？ #####

#####  







---



### 2、MongoDB ###

关于 `MongoDB` 的学习：https://cuiqingcai.com/7121.html

MongoDB 是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的，MongoDB 是一个基于分布式文件存储的数据库。

关于分布式计算的优缺点可以参考 MongoDB 的教程。

**MongoDB 将数据存储为一个文档，数据结构由键值(key=>value)对组成。MongoDB 文档类似于 JSON 对象。字段值可以包含其他文档，数组及文档数组。**

在 MongoDB 中不支持表连接，而且 MongoDB 自动将 id 设为主键。

对于型数据库中每个表来讲，可以在MongoDB中转化成为一个个字典。同一个表中一行数据是一个字典。如下：

![img](https://www.runoob.com/wp-content/uploads/2013/10/Figure-1-Mapping-Table-to-Collection-1.png)

---

最好找一个比较好的 MongoDB 管理工具，这里使用 Studio 3T，可以比较方便的管理 MongoDB，如果后面遇见更加方便的会结合起来使用。

使用 Studio 3T 可以比较方便的导入关系型数据的的数据进去，比如 MySQL。Studio 3T 中提供三种数据预览方式，一种是表格类型，一种是 JSON 格式，另外一种是树形，都比较直观。

***关于自建的 _id :*** *在文档中肯定存在一个这个键，类型可以是任何类型，默认是`ObjectID`对象，而且每个文档都有一个唯一的 _id ，确保文档能被唯一标识。这个键是按照插入数据的顺序生成的，以 16 进制的数据进行增长，就是从 0 - f ，f 完了之后进一位。* 

参考：https://www.cnblogs.com/weilunhui/p/6861938.html



**使用 Python 连接 MongoDB：** 

```python
def operating_mongodb():
    try:
        myclinent = pymongo.MongoClient('localhost', 27017)
        mydb = myclinent.dytt_movie	# 连接到数据库
        result_data = mydb.test	# 连接到数据库中的集合
        for i in result_data.find(): 
            print(i)	# 查找集合中的每个数据，并输出。
        one_result = result_data.find_one({'id': 1})
        print(one_result)
        print(type(one_result))	#查看单条结果的数据类型。
    except Exception as err:
        print(err)
```

首先在命令行窗口安装 `pymongo` 模块。

```python
pip3 install pymongo
```

然后输入地址和端口号进行连接。

```python
 def creat_collections():   
    try:
        myclient = pymongo.MongoClient('localhost', 27017)
        mydb = myclient.world   # 不存在会新建一个数据库
        result = mydb.dytt_mongodb  # 不存在的话也会新建一个集合
        result.insert({'movie_name': item['movie_name'],
        'movie_date': item['movie_date'], 'movie_url': item['movie_url']})
        print('ok')
    except Exception as err:
        print(err)
```

如果连接的数据库不存在则会默认新建一个，需要查询的集合如果也不存在，那么也会新建一个集合。

**MongoDB 文档 CRUD 操作：** 

插入操作：

`db.collection.insertOne()`：将单个文档插入集合。

`db.collection.insertMany()`：多个文档插入集合。

`db.collection.insert()`：单个或者多个插入集合。

### 3、关于对`MongoDB`和`Redis`进行操作和优化的问题。 ###

### 4、关系型数据库和非关系型数据库的区别。 ###

实际上来讲，只是用不同的方法来实现同一件事情。从以下几个方面来简单说明以下两者的区别！以MySQL和MongoDB为例。

1.   两者的存储数据的方式是不一样的，MySQL是以一种二维表的方式。MongoDB是以文档的方式，相同类型的文档存在一个集合中。MySQL中存在表结构，包括表名，字段名和字段数据类型。
2.   两者的事物也是有区别的，MySQL中保持ACID原则，原子性、一致性、独立性、持久性！但是在MongoDB中只有原子性。在MongoDB4.0中引入了事物的功能，用户需要创建一个接口session、然后再session中开始和提交事物。
3.   MySQL需要创建表和字段才能存储数据，MongoDB不需要创建表。MySQL需要保证数据完整性，实体完整性，域完整性，参照完整性，用户自定义完整性！
4.   两者的语句和查询方式不同，MySQL使用结构化查询语言，MongoDB有自己的查询方式。
5.   MySQL的读写性能不如MongoDB。两者的应用方面不一样。

